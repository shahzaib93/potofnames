"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./plugins/amazing-spin-wheel-game/index.js":
/*!**************************************************!*\
  !*** ./plugins/amazing-spin-wheel-game/index.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\nvar _s = $RefreshSig$();\nvar React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nvar WheelComponent = function WheelComponent(_ref) {\n    _s();\n    // console.log(_ref.segments);\n    var segments = _ref.segments, segColors = _ref.segColors, winningSegment = _ref.winningSegment, onFinished = _ref.onFinished, _ref$primaryColor = _ref.primaryColor, primaryColor = _ref$primaryColor === void 0 ? 'black' : _ref$primaryColor, _ref$contrastColor = _ref.contrastColor, contrastColor = _ref$contrastColor === void 0 ? 'white' : _ref$contrastColor, _ref$isOnlyOnce = _ref.isOnlyOnce, isOnlyOnce = _ref$isOnlyOnce === void 0 ? true : _ref$isOnlyOnce, _ref$size = _ref.size, size = _ref$size === void 0 ? 290 : _ref$size, _ref$upDuration = _ref.upDuration, upDuration = _ref$upDuration === void 0 ? 100 : _ref$upDuration, _ref$downDuration = _ref.downDuration, downDuration = _ref$downDuration === void 0 ? 1000 : _ref$downDuration, _ref$fontFamily = _ref.fontFamily, fontFamily = _ref$fontFamily === void 0 ? 'proxima-nova' : _ref$fontFamily;\n    var currentSegment = '';\n    var isStarted = false;\n    var _useState = React.useState(false), isFinished = _useState[0], setFinished = _useState[1];\n    var timerHandle = 0;\n    var timerDelay = segments.length;\n    var angleCurrent = 0;\n    var angleDelta = 0;\n    var canvasContext = null;\n    var maxSpeed = Math.PI / (\"\" + segments.length);\n    var upTime = segments.length * upDuration;\n    var downTime = segments.length * downDuration;\n    var spinStart = 0;\n    var frames = 0;\n    var centerX = 300;\n    var centerY = 300;\n    React.useEffect(function() {\n        wheelInit();\n    // setTimeout(function () {\n    //   // window.scrollTo(0, 1);\n    // }, 0);\n    }, []);\n    var wheelInit = function wheelInit() {\n        initCanvas();\n        wheelDraw();\n    };\n    var initCanvas = function initCanvas() {\n        var canvas = document.getElementById('canvas');\n        canvasContext = canvas.getContext('2d');\n        // var background = new Image();\n        // background.src = \"../wheel_frame.png\";\n        // canvasContext.drawImage(background,100,100,4000,2770);  \n        var spinBtn = document.getElementById('spinBtn');\n        console.log(\"33333\");\n        spinBtn.addEventListener('click', spin, false);\n    };\n    var spin = function spin() {\n        isStarted = true;\n        if (timerHandle === 0) {\n            spinStart = new Date().getTime();\n            maxSpeed = Math.PI / segments.length;\n            frames = 0;\n            timerHandle = setInterval(onTimerTick, timerDelay);\n        }\n    };\n    var onTimerTick = function onTimerTick() {\n        frames++;\n        draw();\n        var duration = new Date().getTime() - spinStart;\n        var progress = 0;\n        var finished = false;\n        if (duration < upTime) {\n            progress = duration / upTime;\n            angleDelta = maxSpeed * Math.sin(progress * Math.PI / 2);\n        } else {\n            if (winningSegment) {\n                if (currentSegment === winningSegment && frames > segments.length) {\n                    progress = duration / upTime;\n                    angleDelta = maxSpeed * Math.sin(progress * Math.PI / 2 + Math.PI / 2);\n                    progress = 1;\n                } else {\n                    progress = duration / downTime;\n                    angleDelta = maxSpeed * Math.sin(progress * Math.PI / 2 + Math.PI / 2);\n                }\n            } else {\n                progress = duration / downTime;\n                angleDelta = maxSpeed * Math.sin(progress * Math.PI / 2 + Math.PI / 2);\n            }\n            if (progress >= 1) finished = true;\n        }\n        angleCurrent += angleDelta;\n        while(angleCurrent >= Math.PI * 2){\n            angleCurrent -= Math.PI * 2;\n        }\n        if (finished) {\n            setFinished(true);\n            onFinished(currentSegment);\n            clearInterval(timerHandle);\n            timerHandle = 0;\n            angleDelta = 0;\n        }\n    };\n    var wheelDraw = function wheelDraw() {\n        clear();\n        drawWheel();\n        drawNeedle();\n    };\n    var draw = function draw() {\n        clear();\n        drawWheel();\n        drawNeedle();\n    };\n    var drawSegment = function drawSegment(key, lastAngle, angle) {\n        var ctx = canvasContext;\n        var value = segments[key];\n        ctx.save();\n        ctx.beginPath();\n        ctx.moveTo(centerX, centerY);\n        ctx.arc(centerX, centerY, size, lastAngle, angle, false);\n        ctx.lineTo(centerX, centerY);\n        ctx.closePath();\n        ctx.fillStyle = segColors[key];\n        ctx.fill();\n        ctx.stroke();\n        ctx.save();\n        ctx.translate(centerX, centerY);\n        ctx.rotate((lastAngle + angle) / 2);\n        ctx.fillStyle = contrastColor;\n        ctx.font = 'bold 1em ' + fontFamily;\n        ctx.fillText(value.substr(0, 21), size / 2 + 20, 0);\n        ctx.restore();\n    };\n    var drawWheel = function drawWheel() {\n        var ctx = canvasContext;\n        var lastAngle = angleCurrent;\n        var len = segments.length;\n        var PI2 = Math.PI * 2;\n        ctx.lineWidth = 1;\n        ctx.strokeStyle = primaryColor;\n        ctx.textBaseline = 'middle';\n        ctx.textAlign = 'center';\n        ctx.font = '1em ' + fontFamily;\n        for(var i = 1; i <= len; i++){\n            var angle = PI2 * (i / len) + angleCurrent;\n            drawSegment(i - 1, lastAngle, angle);\n            lastAngle = angle;\n        }\n        ctx.beginPath();\n        ctx.arc(centerX, centerY, 50, 0, PI2, false);\n        ctx.closePath();\n        ctx.fillStyle = primaryColor;\n        ctx.lineWidth = 10;\n        ctx.strokeStyle = contrastColor;\n        ctx.fill();\n        ctx.font = 'bold 1em ' + fontFamily;\n        ctx.fillStyle = contrastColor;\n        ctx.textAlign = 'center';\n        // ctx.fillText(buttonText, centerX, centerY + 3);\n        ctx.stroke();\n        ctx.beginPath();\n        ctx.arc(centerX, centerY, size, 0, PI2, false);\n        ctx.closePath();\n        ctx.lineWidth = 10;\n        ctx.strokeStyle = primaryColor;\n        ctx.stroke();\n    };\n    var drawNeedle = function drawNeedle() {\n        var ctx = canvasContext;\n        // ctx.lineWidth = 1;\n        // ctx.strokeStyle = contrastColor;\n        // ctx.fileStyle = contrastColor;\n        // ctx.beginPath();\n        // ctx.moveTo(centerX + 20, centerY - 50);\n        // ctx.lineTo(centerX - 20, centerY - 50);\n        // ctx.lineTo(centerX, centerY - 70);\n        // ctx.closePath();\n        // ctx.fill();\n        var change = angleCurrent + Math.PI / 2;\n        var i = segments.length - Math.floor(change / (Math.PI * 2) * segments.length) - 1;\n        if (i < 0) i = i + segments.length;\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n        ctx.fillStyle = primaryColor;\n        ctx.font = 'bold 1.5em ' + fontFamily;\n        currentSegment = segments[i];\n        isStarted && ctx.fillText(currentSegment, centerX + 10, centerY + size + 50);\n    };\n    var clear = function clear() {\n        var ctx = canvasContext;\n        ctx.clearRect(0, 0, 1000, 800);\n    };\n    return React.createElement(\"div\", {\n        id: \"wheel\",\n        width: \"600\",\n        height: \"600\"\n    }, React.createElement(\"canvas\", {\n        id: \"canvas\",\n        width: \"600\",\n        height: \"600\",\n        className: \"mx-auto d-block canvas\",\n        style: {\n            pointerEvents: isFinished && isOnlyOnce ? 'none' : 'auto'\n        }\n    }));\n};\n_s(WheelComponent, \"EEbBbH2V7/JbIWkmnfgP/KlFBtU=\");\n_c = WheelComponent;\nmodule.exports = React.memo(WheelComponent);\nvar _c;\n$RefreshReg$(_c, \"WheelComponent\");\n\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wbHVnaW5zL2FtYXppbmctc3Bpbi13aGVlbC1nYW1lL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7OztBQUNBLEdBQUcsQ0FBQ0EsS0FBSyxHQUFHQyxtQkFBTyxDQUFDLDRDQUFPO0FBQzNCLEdBQUcsQ0FBQ0MsY0FBYyxHQUFHLFFBQVEsQ0FBQ0EsY0FBYyxDQUFDQyxJQUFJLEVBQUUsQ0FBQzs7SUFDbEQsRUFBOEI7SUFDOUIsR0FBRyxDQUFDQyxRQUFRLEdBQUdELElBQUksQ0FBQ0MsUUFBUSxFQUN4QkMsU0FBUyxHQUFHRixJQUFJLENBQUNFLFNBQVMsRUFDMUJDLGNBQWMsR0FBR0gsSUFBSSxDQUFDRyxjQUFjLEVBQ3BDQyxVQUFVLEdBQUdKLElBQUksQ0FBQ0ksVUFBVSxFQUM1QkMsaUJBQWlCLEdBQUdMLElBQUksQ0FBQ00sWUFBWSxFQUNyQ0EsWUFBWSxHQUFHRCxpQkFBaUIsS0FBSyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQU8sU0FBR0EsaUJBQWlCLEVBQ3pFRSxrQkFBa0IsR0FBR1AsSUFBSSxDQUFDUSxhQUFhLEVBQ3ZDQSxhQUFhLEdBQUdELGtCQUFrQixLQUFLLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBTyxTQUFHQSxrQkFBa0IsRUFDNUVFLGVBQWUsR0FBR1QsSUFBSSxDQUFDVSxVQUFVLEVBQ2pDQSxVQUFVLEdBQUdELGVBQWUsS0FBSyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksR0FBR0EsZUFBZSxFQUNoRUUsU0FBUyxHQUFHWCxJQUFJLENBQUNZLElBQUksRUFDckJBLElBQUksR0FBR0QsU0FBUyxLQUFLLElBQUksQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHQSxTQUFTLEVBQzdDRSxlQUFlLEdBQUdiLElBQUksQ0FBQ2MsVUFBVSxFQUNqQ0EsVUFBVSxHQUFHRCxlQUFlLEtBQUssSUFBSSxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQUdBLGVBQWUsRUFDL0RFLGlCQUFpQixHQUFHZixJQUFJLENBQUNnQixZQUFZLEVBQ3JDQSxZQUFZ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QUFLLEdBQUcsUUFBUSxDQUFDQSxLQUFLLEdBQUcsQ0FBQztRQUM1QixHQUFHLENBQUNPLEdBQUcsR0FBR3hDLGFBQWE7UUFDdkJ3QyxHQUFHLENBQUMwQixTQUFTLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLEVBQUUsR0FBRztJQUMvQixDQUFDO0lBRUQsTUFBTSxDQUFDbkcsS0FBSyxDQUFDb0csYUFBYSxDQUFDLENBQUssTUFBRSxDQUFDO1FBQ2pDQyxFQUFFLEVBQUUsQ0FBTztRQUNYQyxLQUFLLEVBQUUsQ0FBSztRQUNaQyxNQUFNLEVBQUUsQ0FBSztJQUNmLENBQUMsRUFBRXZHLEtBQUssQ0FBQ29HLGFBQWEsQ0FBQyxDQUFRLFNBQUUsQ0FBQztRQUNoQ0MsRUFBRSxFQUFFLENBQVE7UUFDWkMsS0FBSyxFQUFFLENBQUs7UUFDWkMsTUFBTSxFQUFFLENBQUs7UUFDYkMsU0FBUyxFQUFDLENBQXdCO1FBQ2xDQyxLQUFLLEVBQUUsQ0FBQztZQUNOQyxhQUFhLEVBQUVoRixVQUFVLElBQUliLFVBQVUsR0FBRyxDQUFNLFFBQUcsQ0FBTTtRQUMzRCxDQUFDO0lBQ0gsQ0FBQztBQUNILENBQUM7R0FyT0dYLGNBQWM7S0FBZEEsY0FBYztBQXVPbEJ5RyxNQUFNLENBQUNDLE9BQU8sR0FBRzVHLEtBQUssQ0FBQzZHLElBQUksQ0FBQzNHLGNBQWMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vcGx1Z2lucy9hbWF6aW5nLXNwaW4td2hlZWwtZ2FtZS9pbmRleC5qcz83NTVhIl0sInNvdXJjZXNDb250ZW50IjpbIlxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBXaGVlbENvbXBvbmVudCA9IGZ1bmN0aW9uIFdoZWVsQ29tcG9uZW50KF9yZWYpIHtcbiAgLy8gY29uc29sZS5sb2coX3JlZi5zZWdtZW50cyk7XG4gIHZhciBzZWdtZW50cyA9IF9yZWYuc2VnbWVudHMsXG4gICAgICBzZWdDb2xvcnMgPSBfcmVmLnNlZ0NvbG9ycyxcbiAgICAgIHdpbm5pbmdTZWdtZW50ID0gX3JlZi53aW5uaW5nU2VnbWVudCxcbiAgICAgIG9uRmluaXNoZWQgPSBfcmVmLm9uRmluaXNoZWQsXG4gICAgICBfcmVmJHByaW1hcnlDb2xvciA9IF9yZWYucHJpbWFyeUNvbG9yLFxuICAgICAgcHJpbWFyeUNvbG9yID0gX3JlZiRwcmltYXJ5Q29sb3IgPT09IHZvaWQgMCA/ICdibGFjaycgOiBfcmVmJHByaW1hcnlDb2xvcixcbiAgICAgIF9yZWYkY29udHJhc3RDb2xvciA9IF9yZWYuY29udHJhc3RDb2xvcixcbiAgICAgIGNvbnRyYXN0Q29sb3IgPSBfcmVmJGNvbnRyYXN0Q29sb3IgPT09IHZvaWQgMCA/ICd3aGl0ZScgOiBfcmVmJGNvbnRyYXN0Q29sb3IsXG4gICAgICBfcmVmJGlzT25seU9uY2UgPSBfcmVmLmlzT25seU9uY2UsXG4gICAgICBpc09ubHlPbmNlID0gX3JlZiRpc09ubHlPbmNlID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZiRpc09ubHlPbmNlLFxuICAgICAgX3JlZiRzaXplID0gX3JlZi5zaXplLFxuICAgICAgc2l6ZSA9IF9yZWYkc2l6ZSA9PT0gdm9pZCAwID8gMjkwIDogX3JlZiRzaXplLFxuICAgICAgX3JlZiR1cER1cmF0aW9uID0gX3JlZi51cER1cmF0aW9uLFxuICAgICAgdXBEdXJhdGlvbiA9IF9yZWYkdXBEdXJhdGlvbiA9PT0gdm9pZCAwID8gMTAwIDogX3JlZiR1cER1cmF0aW9uLFxuICAgICAgX3JlZiRkb3duRHVyYXRpb24gPSBfcmVmLmRvd25EdXJhdGlvbixcbiAgICAgIGRvd25EdXJhdGlvbiA9IF9yZWYkZG93bkR1cmF0aW9uID09PSB2b2lkIDAgPyAxMDAwIDogX3JlZiRkb3duRHVyYXRpb24sXG4gICAgICBfcmVmJGZvbnRGYW1pbHkgPSBfcmVmLmZvbnRGYW1pbHksXG4gICAgICBmb250RmFtaWx5ID0gX3JlZiRmb250RmFtaWx5ID09PSB2b2lkIDAgPyAncHJveGltYS1ub3ZhJyA6IF9yZWYkZm9udEZhbWlseTtcbiAgdmFyIGN1cnJlbnRTZWdtZW50ID0gJyc7XG4gIHZhciBpc1N0YXJ0ZWQgPSBmYWxzZTtcblxuICB2YXIgX3VzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpLFxuICAgICAgaXNGaW5pc2hlZCA9IF91c2VTdGF0ZVswXSxcbiAgICAgIHNldEZpbmlzaGVkID0gX3VzZVN0YXRlWzFdO1xuXG4gIHZhciB0aW1lckhhbmRsZSA9IDA7XG4gIHZhciB0aW1lckRlbGF5ID0gc2VnbWVudHMubGVuZ3RoO1xuICB2YXIgYW5nbGVDdXJyZW50ID0gMDtcbiAgdmFyIGFuZ2xlRGVsdGEgPSAwO1xuICB2YXIgY2FudmFzQ29udGV4dCA9IG51bGw7XG4gIHZhciBtYXhTcGVlZCA9IE1hdGguUEkgLyAoXCJcIiArIHNlZ21lbnRzLmxlbmd0aCk7XG4gIHZhciB1cFRpbWUgPSBzZWdtZW50cy5sZW5ndGggKiB1cER1cmF0aW9uO1xuICB2YXIgZG93blRpbWUgPSBzZWdtZW50cy5sZW5ndGggKiBkb3duRHVyYXRpb247XG4gIHZhciBzcGluU3RhcnQgPSAwO1xuICB2YXIgZnJhbWVzID0gMDtcbiAgdmFyIGNlbnRlclggPSAzMDA7XG4gIHZhciBjZW50ZXJZID0gMzAwO1xuXG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgd2hlZWxJbml0KCk7XG4gICAgLy8gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgLy8gICAvLyB3aW5kb3cuc2Nyb2xsVG8oMCwgMSk7XG4gICAgLy8gfSwgMCk7XG4gIH0sIFtdKTtcblxuICB2YXIgd2hlZWxJbml0ID0gZnVuY3Rpb24gd2hlZWxJbml0KCkge1xuICAgIGluaXRDYW52YXMoKTtcbiAgICB3aGVlbERyYXcoKTtcbiAgfTtcblxuICB2YXIgaW5pdENhbnZhcyA9IGZ1bmN0aW9uIGluaXRDYW52YXMoKSB7XG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYW52YXMnKTtcbiAgICBjYW52YXNDb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAvLyB2YXIgYmFja2dyb3VuZCA9IG5ldyBJbWFnZSgpO1xuICAgIC8vIGJhY2tncm91bmQuc3JjID0gXCIuLi93aGVlbF9mcmFtZS5wbmdcIjtcbiAgICAvLyBjYW52YXNDb250ZXh0LmRyYXdJbWFnZShiYWNrZ3JvdW5kLDEwMCwxMDAsNDAwMCwyNzcwKTsgIFxuXG4gICAgdmFyIHNwaW5CdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3BpbkJ0bicpO1xuICAgIGNvbnNvbGUubG9nKFwiMzMzMzNcIik7XG4gICAgc3BpbkJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHNwaW4sIGZhbHNlKTtcbiAgfTtcblxuICB2YXIgc3BpbiA9IGZ1bmN0aW9uIHNwaW4oKSB7XG4gICAgaXNTdGFydGVkID0gdHJ1ZTtcblxuICAgIGlmICh0aW1lckhhbmRsZSA9PT0gMCkge1xuICAgICAgc3BpblN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICBtYXhTcGVlZCA9IE1hdGguUEkgLyBzZWdtZW50cy5sZW5ndGg7XG4gICAgICBmcmFtZXMgPSAwO1xuICAgICAgdGltZXJIYW5kbGUgPSBzZXRJbnRlcnZhbChvblRpbWVyVGljaywgdGltZXJEZWxheSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBvblRpbWVyVGljayA9IGZ1bmN0aW9uIG9uVGltZXJUaWNrKCkge1xuICAgIGZyYW1lcysrO1xuICAgIGRyYXcoKTtcbiAgICB2YXIgZHVyYXRpb24gPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHNwaW5TdGFydDtcbiAgICB2YXIgcHJvZ3Jlc3MgPSAwO1xuICAgIHZhciBmaW5pc2hlZCA9IGZhbHNlO1xuXG4gICAgaWYgKGR1cmF0aW9uIDwgdXBUaW1lKSB7XG4gICAgICBwcm9ncmVzcyA9IGR1cmF0aW9uIC8gdXBUaW1lO1xuICAgICAgYW5nbGVEZWx0YSA9IG1heFNwZWVkICogTWF0aC5zaW4ocHJvZ3Jlc3MgKiBNYXRoLlBJIC8gMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh3aW5uaW5nU2VnbWVudCkge1xuICAgICAgICBpZiAoY3VycmVudFNlZ21lbnQgPT09IHdpbm5pbmdTZWdtZW50ICYmIGZyYW1lcyA+IHNlZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHByb2dyZXNzID0gZHVyYXRpb24gLyB1cFRpbWU7XG4gICAgICAgICAgYW5nbGVEZWx0YSA9IG1heFNwZWVkICogTWF0aC5zaW4ocHJvZ3Jlc3MgKiBNYXRoLlBJIC8gMiArIE1hdGguUEkgLyAyKTtcbiAgICAgICAgICBwcm9ncmVzcyA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvZ3Jlc3MgPSBkdXJhdGlvbiAvIGRvd25UaW1lO1xuICAgICAgICAgIGFuZ2xlRGVsdGEgPSBtYXhTcGVlZCAqIE1hdGguc2luKHByb2dyZXNzICogTWF0aC5QSSAvIDIgKyBNYXRoLlBJIC8gMik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2dyZXNzID0gZHVyYXRpb24gLyBkb3duVGltZTtcbiAgICAgICAgYW5nbGVEZWx0YSA9IG1heFNwZWVkICogTWF0aC5zaW4ocHJvZ3Jlc3MgKiBNYXRoLlBJIC8gMiArIE1hdGguUEkgLyAyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2dyZXNzID49IDEpIGZpbmlzaGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBhbmdsZUN1cnJlbnQgKz0gYW5nbGVEZWx0YTtcblxuICAgIHdoaWxlIChhbmdsZUN1cnJlbnQgPj0gTWF0aC5QSSAqIDIpIHtcbiAgICAgIGFuZ2xlQ3VycmVudCAtPSBNYXRoLlBJICogMjtcbiAgICB9XG5cbiAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgIHNldEZpbmlzaGVkKHRydWUpO1xuICAgICAgb25GaW5pc2hlZChjdXJyZW50U2VnbWVudCk7XG4gICAgICBjbGVhckludGVydmFsKHRpbWVySGFuZGxlKTtcbiAgICAgIHRpbWVySGFuZGxlID0gMDtcbiAgICAgIGFuZ2xlRGVsdGEgPSAwO1xuICAgIH1cbiAgfTtcblxuICB2YXIgd2hlZWxEcmF3ID0gZnVuY3Rpb24gd2hlZWxEcmF3KCkge1xuICAgIGNsZWFyKCk7XG4gICAgZHJhd1doZWVsKCk7XG4gICAgZHJhd05lZWRsZSgpO1xuICB9O1xuXG4gIHZhciBkcmF3ID0gZnVuY3Rpb24gZHJhdygpIHtcbiAgICBjbGVhcigpO1xuICAgIGRyYXdXaGVlbCgpO1xuICAgIGRyYXdOZWVkbGUoKTtcbiAgfTtcblxuICB2YXIgZHJhd1NlZ21lbnQgPSBmdW5jdGlvbiBkcmF3U2VnbWVudChrZXksIGxhc3RBbmdsZSwgYW5nbGUpIHtcbiAgICB2YXIgY3R4ID0gY2FudmFzQ29udGV4dDtcbiAgICB2YXIgdmFsdWUgPSBzZWdtZW50c1trZXldO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oY2VudGVyWCwgY2VudGVyWSk7XG4gICAgY3R4LmFyYyhjZW50ZXJYLCBjZW50ZXJZLCBzaXplLCBsYXN0QW5nbGUsIGFuZ2xlLCBmYWxzZSk7XG4gICAgY3R4LmxpbmVUbyhjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IHNlZ0NvbG9yc1trZXldO1xuICAgIGN0eC5maWxsKCk7XG4gICAgY3R4LnN0cm9rZSgpO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnRyYW5zbGF0ZShjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICBjdHgucm90YXRlKChsYXN0QW5nbGUgKyBhbmdsZSkgLyAyKTtcbiAgICBjdHguZmlsbFN0eWxlID0gY29udHJhc3RDb2xvcjtcbiAgICBjdHguZm9udCA9ICdib2xkIDFlbSAnICsgZm9udEZhbWlseTtcbiAgICBjdHguZmlsbFRleHQodmFsdWUuc3Vic3RyKDAsIDIxKSwgc2l6ZSAvIDIgKyAyMCwgMCk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfTtcblxuICB2YXIgZHJhd1doZWVsID0gZnVuY3Rpb24gZHJhd1doZWVsKCkge1xuICAgIHZhciBjdHggPSBjYW52YXNDb250ZXh0O1xuICAgIHZhciBsYXN0QW5nbGUgPSBhbmdsZUN1cnJlbnQ7XG4gICAgdmFyIGxlbiA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICB2YXIgUEkyID0gTWF0aC5QSSAqIDI7XG4gICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gcHJpbWFyeUNvbG9yO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgY3R4LmZvbnQgPSAnMWVtICcgKyBmb250RmFtaWx5O1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gbGVuOyBpKyspIHtcbiAgICAgIHZhciBhbmdsZSA9IFBJMiAqIChpIC8gbGVuKSArIGFuZ2xlQ3VycmVudDtcbiAgICAgIGRyYXdTZWdtZW50KGkgLSAxLCBsYXN0QW5nbGUsIGFuZ2xlKTtcbiAgICAgIGxhc3RBbmdsZSA9IGFuZ2xlO1xuICAgIH1cblxuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHguYXJjKGNlbnRlclgsIGNlbnRlclksIDUwLCAwLCBQSTIsIGZhbHNlKTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IHByaW1hcnlDb2xvcjtcbiAgICBjdHgubGluZVdpZHRoID0gMTA7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gY29udHJhc3RDb2xvcjtcbiAgICBjdHguZmlsbCgpO1xuICAgIGN0eC5mb250ID0gJ2JvbGQgMWVtICcgKyBmb250RmFtaWx5O1xuICAgIGN0eC5maWxsU3R5bGUgPSBjb250cmFzdENvbG9yO1xuICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAvLyBjdHguZmlsbFRleHQoYnV0dG9uVGV4dCwgY2VudGVyWCwgY2VudGVyWSArIDMpO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmFyYyhjZW50ZXJYLCBjZW50ZXJZLCBzaXplLCAwLCBQSTIsIGZhbHNlKTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgY3R4LmxpbmVXaWR0aCA9IDEwO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IHByaW1hcnlDb2xvcjtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH07XG5cbiAgdmFyIGRyYXdOZWVkbGUgPSBmdW5jdGlvbiBkcmF3TmVlZGxlKCkge1xuICAgIHZhciBjdHggPSBjYW52YXNDb250ZXh0O1xuICAgIC8vIGN0eC5saW5lV2lkdGggPSAxO1xuICAgIC8vIGN0eC5zdHJva2VTdHlsZSA9IGNvbnRyYXN0Q29sb3I7XG4gICAgLy8gY3R4LmZpbGVTdHlsZSA9IGNvbnRyYXN0Q29sb3I7XG4gICAgLy8gY3R4LmJlZ2luUGF0aCgpO1xuICAgIC8vIGN0eC5tb3ZlVG8oY2VudGVyWCArIDIwLCBjZW50ZXJZIC0gNTApO1xuICAgIC8vIGN0eC5saW5lVG8oY2VudGVyWCAtIDIwLCBjZW50ZXJZIC0gNTApO1xuICAgIC8vIGN0eC5saW5lVG8oY2VudGVyWCwgY2VudGVyWSAtIDcwKTtcbiAgICAvLyBjdHguY2xvc2VQYXRoKCk7XG4gICAgLy8gY3R4LmZpbGwoKTtcbiAgICB2YXIgY2hhbmdlID0gYW5nbGVDdXJyZW50ICsgTWF0aC5QSSAvIDI7XG4gICAgdmFyIGkgPSBzZWdtZW50cy5sZW5ndGggLSBNYXRoLmZsb29yKGNoYW5nZSAvIChNYXRoLlBJICogMikgKiBzZWdtZW50cy5sZW5ndGgpIC0gMTtcbiAgICBpZiAoaSA8IDApIGkgPSBpICsgc2VnbWVudHMubGVuZ3RoO1xuICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgY3R4LmZpbGxTdHlsZSA9IHByaW1hcnlDb2xvcjtcbiAgICBjdHguZm9udCA9ICdib2xkIDEuNWVtICcgKyBmb250RmFtaWx5O1xuICAgIGN1cnJlbnRTZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgaXNTdGFydGVkICYmIGN0eC5maWxsVGV4dChjdXJyZW50U2VnbWVudCwgY2VudGVyWCArIDEwLCBjZW50ZXJZICsgc2l6ZSArIDUwKTtcbiAgfTtcblxuICB2YXIgY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB2YXIgY3R4ID0gY2FudmFzQ29udGV4dDtcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIDEwMDAsIDgwMCk7XG4gIH07XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGlkOiBcIndoZWVsXCIsXG4gICAgd2lkdGg6IFwiNjAwXCIsXG4gICAgaGVpZ2h0OiBcIjYwMFwiLFxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIsIHtcbiAgICBpZDogXCJjYW52YXNcIixcbiAgICB3aWR0aDogXCI2MDBcIixcbiAgICBoZWlnaHQ6IFwiNjAwXCIsXG4gICAgY2xhc3NOYW1lOlwibXgtYXV0byBkLWJsb2NrIGNhbnZhc1wiLFxuICAgIHN0eWxlOiB7XG4gICAgICBwb2ludGVyRXZlbnRzOiBpc0ZpbmlzaGVkICYmIGlzT25seU9uY2UgPyAnbm9uZScgOiAnYXV0bydcbiAgICB9XG4gIH0pKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3QubWVtbyhXaGVlbENvbXBvbmVudCk7Il0sIm5hbWVzIjpbIlJlYWN0IiwicmVxdWlyZSIsIldoZWVsQ29tcG9uZW50IiwiX3JlZiIsInNlZ21lbnRzIiwic2VnQ29sb3JzIiwid2lubmluZ1NlZ21lbnQiLCJvbkZpbmlzaGVkIiwiX3JlZiRwcmltYXJ5Q29sb3IiLCJwcmltYXJ5Q29sb3IiLCJfcmVmJGNvbnRyYXN0Q29sb3IiLCJjb250cmFzdENvbG9yIiwiX3JlZiRpc09ubHlPbmNlIiwiaXNPbmx5T25jZSIsIl9yZWYkc2l6ZSIsInNpemUiLCJfcmVmJHVwRHVyYXRpb24iLCJ1cER1cmF0aW9uIiwiX3JlZiRkb3duRHVyYXRpb24iLCJkb3duRHVyYXRpb24iLCJfcmVmJGZvbnRGYW1pbHkiLCJmb250RmFtaWx5IiwiY3VycmVudFNlZ21lbnQiLCJpc1N0YXJ0ZWQiLCJfdXNlU3RhdGUiLCJ1c2VTdGF0ZSIsImlzRmluaXNoZWQiLCJzZXRGaW5pc2hlZCIsInRpbWVySGFuZGxlIiwidGltZXJEZWxheSIsImxlbmd0aCIsImFuZ2xlQ3VycmVudCIsImFuZ2xlRGVsdGEiLCJjYW52YXNDb250ZXh0IiwibWF4U3BlZWQiLCJNYXRoIiwiUEkiLCJ1cFRpbWUiLCJkb3duVGltZSIsInNwaW5TdGFydCIsImZyYW1lcyIsImNlbnRlclgiLCJjZW50ZXJZIiwidXNlRWZmZWN0Iiwid2hlZWxJbml0IiwiaW5pdENhbnZhcyIsIndoZWVsRHJhdyIsImNhbnZhcyIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJnZXRDb250ZXh0Iiwic3BpbkJ0biIsImNvbnNvbGUiLCJsb2ciLCJhZGRFdmVudExpc3RlbmVyIiwic3BpbiIsIkRhdGUiLCJnZXRUaW1lIiwic2V0SW50ZXJ2YWwiLCJvblRpbWVyVGljayIsImRyYXciLCJkdXJhdGlvbiIsInByb2dyZXNzIiwiZmluaXNoZWQiLCJzaW4iLCJjbGVhckludGVydmFsIiwiY2xlYXIiLCJkcmF3V2hlZWwiLCJkcmF3TmVlZGxlIiwiZHJhd1NlZ21lbnQiLCJrZXkiLCJsYXN0QW5nbGUiLCJhbmdsZSIsImN0eCIsInZhbHVlIiwic2F2ZSIsImJlZ2luUGF0aCIsIm1vdmVUbyIsImFyYyIsImxpbmVUbyIsImNsb3NlUGF0aCIsImZpbGxTdHlsZSIsImZpbGwiLCJzdHJva2UiLCJ0cmFuc2xhdGUiLCJyb3RhdGUiLCJmb250IiwiZmlsbFRleHQiLCJzdWJzdHIiLCJyZXN0b3JlIiwibGVuIiwiUEkyIiwibGluZVdpZHRoIiwic3Ryb2tlU3R5bGUiLCJ0ZXh0QmFzZWxpbmUiLCJ0ZXh0QWxpZ24iLCJpIiwiY2hhbmdlIiwiZmxvb3IiLCJjbGVhclJlY3QiLCJjcmVhdGVFbGVtZW50IiwiaWQiLCJ3aWR0aCIsImhlaWdodCIsImNsYXNzTmFtZSIsInN0eWxlIiwicG9pbnRlckV2ZW50cyIsIm1vZHVsZSIsImV4cG9ydHMiLCJtZW1vIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./plugins/amazing-spin-wheel-game/index.js\n");

/***/ })

});